use std::{env, fs};
use std::path::PathBuf;
use std::process::Command;
use bindgen::EnumVariation;

const SHADERS_SRC: &str = "shaders/src";

const BINDING_HEADER: &str = "
// The names of the autogenerated functions will not adhere to Rust's formatting guidelines.
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::missing_safety_doc)]

// Type aliases so the rust side can use glam instead of my implementations.
type float4=glam::Vec4;
type float4x4=glam::Mat4;
type float3=glam::Vec3A;
";

// This feels insane. But also cc-rs refuses to create .o files from anything that ends in .metal
// and Xcode refuses to link against metal_stdlib for anything that doesn't end in .metal so here we are.
fn main() {
    let is_macos = env::var("TARGET").unwrap().contains("-apple-darwin");
    if !is_macos {
        println!("cargo:warning=Since gpu_runner uses Metal, it will only work when targeting MacOS.");
    }
    cargo_watch_changes();
    change_file_extensions("metal", "cc");
    build_as_cpp();
    run_bindgen();
    change_file_extensions("cc", "metal");
    build_as_msl();
    change_file_extensions("metal", "cc");
}

/// Generates rust versions of all the structs in the shader code and bindings to functions.
fn run_bindgen() {
    bindgen::Builder::default()
        .header("shaders/src/shaders.cc")
        .clang_args(&["-DNOT_BUILDING_AS_MSL", "-DDOING_RUST_BINDGEN", "-x", "c++", "-std=c++14"])
        .default_enum_style(EnumVariation::Rust { non_exhaustive: false })
        .blocklist_type("float4")
        .blocklist_type("float4x4")
        .blocklist_type("float3")
        .raw_line(BINDING_HEADER)
        .generate()
        .unwrap()
        .write_to_file("src/bindings.rs")
        .unwrap();
}


/// Compiles the shaders xcode project into a .metallib file.
fn build_as_msl(){
    let shaders = Command::new("xcodebuild").arg("build").current_dir("shaders").status();
    match shaders {
        Ok(s) => if !s.success() {
            panic!("xcodebuild failed with {s}.");
        }
        Err(e) => {
            panic!("Failed to run xcodebuild: {e}. Install the Xcode Command Line Tools.");
        }
    }

    // Move it into the src directory so I can use include_bytes.
    fs::copy("shaders/build/Release/shaders.metallib", "src/bin/shaders.metallib").unwrap();
}

/// Compile the metal code as c++ so rust code can call it on the cpu for debugging.
fn build_as_cpp(){
    cc::Build::new()
        .define("NOT_BUILDING_AS_MSL", None)
        .cpp(true)
        .flag("-std=c++14")
        .files(cc_src_files())
        .compile("shaders");
}

fn cargo_watch_changes(){
    println!("cargo:rerun-if-changed=src");

    // List files individually because changing extensions counts as modifying the dir.
    fs::read_dir(SHADERS_SRC)
        .unwrap()
        .map(|p| { p.unwrap().path() })
        .for_each(|p| {
            println!("cargo:rerun-if-changed={}", p.to_str().unwrap());
        });
}

fn cc_src_files() -> impl Iterator<Item=PathBuf> {
    fs::read_dir(SHADERS_SRC)
        .unwrap()
        .map(|p| { p.unwrap().path() })
        .filter(|p| {
            let e = p.extension().unwrap();
            e != "h" && e != "md"
        })
}

fn change_file_extensions(from: &str, to: &str) {
    cc_src_files()
        .filter(|p| p.extension().unwrap() == from)
        .for_each(|p| {
            let new_path = p.with_extension(to);
            fs::rename(p, new_path).unwrap();
        });
}
